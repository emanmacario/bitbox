package unimelb.bitbox.protocols;

import unimelb.bitbox.util.FileSystemManager.FileSystemEvent;
import unimelb.bitbox.util.FileSystemManager.FileDescriptor;
import unimelb.bitbox.util.Messages;

import java.io.BufferedWriter;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.logging.Logger;

public class PeerClient implements Runnable {
    private static Logger log = Logger.getLogger(PeerClient.class.getName());

    private String host;
    private int port;
    private String mode;
    private Queue<FileSystemEvent> events;
    private Queue<String> messages;
    private BufferedWriter out;
    private boolean closed;
    private DatagramSocket socketUDP;

    // PeerClient constructor
    public PeerClient(String host, int port, Socket socket, String mode, DatagramSocket socketUDP) throws IOException {
        this.host = host;
        this.port = port;
        this.mode = mode;
        this.events = new LinkedList<>();
        this.messages = new LinkedList<>();
        this.out = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), StandardCharsets.UTF_8));
        this.closed = false;
        this.socketUDP = socketUDP;
    }

    /**
     * Handles an outgoing reply to the client,
     * generated by a new file system event.
     * @param fileSystemEvent the file system event
     * @throws IOException
     */
    private void handleOutgoingClientMessage(FileSystemEvent fileSystemEvent) throws IOException {
        String command = fileSystemEvent.event.name();
        FileDescriptor fileDescriptor = fileSystemEvent.fileDescriptor;
        String pathName = fileSystemEvent.pathName;

        // Only for file events, not directory events
        String md5 = null;
        Long lastModified = null;
        Long fileSize = null;

        // Construct and send outgoing request
        String request;
        switch (command) {
            case "DIRECTORY_CREATE":
                request = Messages.getDirectoryCreateRequest(pathName);
                if (mode.equals("tcp")) {send(request); };
                if (mode.equals("udp")) {
                    InetAddress IPAddress = InetAddress.getByName(host);
                    byte[] sendBytes = request.getBytes();
                    DatagramPacket sendPacket = new DatagramPacket(sendBytes, sendBytes.length, IPAddress, port);
                    socketUDP.send(sendPacket);
                }
                break;
            case "DIRECTORY_DELETE":
                request = Messages.getDirectoryDeleteRequest(pathName);
                if (mode.equals("tcp")) {send(request); };
                if (mode.equals("udp")) {
                    InetAddress IPAddress = InetAddress.getByName(host);
                    byte[] sendBytes = request.getBytes();
                    DatagramPacket sendPacket = new DatagramPacket(sendBytes, sendBytes.length, IPAddress, port);
                    socketUDP.send(sendPacket);
                }
                break;
            case "FILE_CREATE":
            case "FILE_DELETE":
            case "FILE_MODIFY":
                assert(fileDescriptor != null);
                md5 = fileDescriptor.md5;
                lastModified = fileDescriptor.lastModified;
                fileSize = fileDescriptor.fileSize;
                switch (command) {
                    case "FILE_CREATE":
                        request = Messages.getFileCreateRequest(md5, lastModified, fileSize, pathName);
                        if (mode.equals("tcp")) {send(request); };
                        if (mode.equals("udp")) {
                            InetAddress IPAddress = InetAddress.getByName(host);
                            byte[] sendBytes = request.getBytes();
                            DatagramPacket sendPacket = new DatagramPacket(sendBytes, sendBytes.length, IPAddress, port);
                            socketUDP.send(sendPacket);
                        }
                        break;
                    case "FILE_DELETE":
                        request = Messages.getFileDeleteRequest(md5, lastModified, fileSize, pathName);
                        if (mode.equals("tcp")) {send(request); };
                        if (mode.equals("udp")) {
                            InetAddress IPAddress = InetAddress.getByName(host);
                            byte[] sendBytes = request.getBytes();
                            DatagramPacket sendPacket = new DatagramPacket(sendBytes, sendBytes.length, IPAddress, port);
                            socketUDP.send(sendPacket);
                        }
                        break;
                    case "FILE_MODIFY":
                        request = Messages.getFileModifyRequest(md5, lastModified, fileSize, pathName);
                        if (mode.equals("tcp")) {send(request); };
                        if (mode.equals("udp")) {
                            InetAddress IPAddress = InetAddress.getByName(host);
                            byte[] sendBytes = request.getBytes();
                            DatagramPacket sendPacket = new DatagramPacket(sendBytes, sendBytes.length, IPAddress, port);
                            socketUDP.send(sendPacket);
                        }
                        break;
                    default:
                        break;
                }
                break;
            default:
                log.warning("Invalid command arose from file system event");
                break;
        }
    }

    public void close() {
        this.closed = true;
    }

    public void enqueue(FileSystemEvent event) {
        this.events.add(event);
    }

    public void enqueue(List<String> messages) {
        this.messages.addAll(messages);
    }

    /**
     * Responsible for handling outgoing requests generated
     * by general file system events to a single connected peer,
     * until that connection is closed. Also generates
     * and sends sync events after every syncInterval period.
     */
    @Override
    public void run() {

        while (!closed) {
            try {
                // Need to sleep to ensure file system events
                // are actually processed. If we don't then
                // for some reason they aren't processed.
                Thread.sleep(50);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            // Process general file system events, relay them
            // as outgoing messages to connected peers
            FileSystemEvent event;
            try {
                while ((event = this.events.poll()) != null) {
                    handleOutgoingClientMessage(event);
                }
            } catch (IOException e) {
                e.printStackTrace();
            }

            // Process enqueued messages to be sent to the connected
            // peer. These are typically FILE_BYTE_REQUEST messages,
            // which allows the corresponding PeerServer thread to
            // not block, by having to send out all requests in one go.
            String message;
            try {
                if ((message = this.messages.poll()) != null) {
                    if (mode.equals("tcp")) {send(message); };
                    if (mode.equals("udp")) {
                        byte[] sendBytes = new byte[1024];
                        InetAddress IPAddress = InetAddress.getByName(host);
                        sendBytes = message.getBytes();
                        DatagramPacket sendPacket = new DatagramPacket(sendBytes, sendBytes.length, IPAddress, port);
                        socketUDP.send(sendPacket);
                    }
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        log.info("Connection to " + host + ":" + port + " has been terminated, PeerClient thread has stopped");
    }

    /**
     * Sends a request/response string to the connected peer.
     * Appends a newline char to the outgoing message.
     * @param message request or response message
     * @throws IOException
     */

    private void send(String message) throws IOException {
        out.write(message + '\n');
        log.info("sending to " + host + ":" + port + " " + message);
        out.flush();
    }
}