package unimelb.bitbox;

import unimelb.bitbox.util.Configuration;
import unimelb.bitbox.util.Document;
import unimelb.bitbox.util.FileSystemManager;
import unimelb.bitbox.util.FileSystemManager.FileSystemEvent;

import java.io.BufferedWriter;
import java.io.IOException;
import java.security.NoSuchAlgorithmException;
import java.util.LinkedList;
import java.util.Queue;
import java.util.logging.Logger;

public class PeerClient implements Runnable {
    private static Logger log = Logger.getLogger(PeerClient.class.getName());

    private Queue<FileSystemEvent> events;
    private FileSystemManager fileSystemManager;
    private BufferedWriter out;
    private boolean closed;
    private int syncInterval;

    // Thread constructor
    public PeerClient(FileSystemManager fileSystemManager, BufferedWriter out) {
        this.fileSystemManager = fileSystemManager;
        this.out = out;
        this.events = new LinkedList<>();
        this.syncInterval = Integer.parseInt(Configuration.getConfigurationValue("syncInterval"));
        this.closed = false;
    }

    /**
     * Handles an outgoing reply to the client,
     * generated by a new file system event.
     * @param fileSystemEvent the file system event
     * @throws IOException
     */
    private void handleOutgoingClientMessage(FileSystemEvent fileSystemEvent) throws IOException {
        String command = fileSystemEvent.event.name();
        FileSystemManager.FileDescriptor fileDescriptor = fileSystemEvent.fileDescriptor;
        String pathName = fileSystemEvent.pathName;

        // Only for file events, not directory events
        String md5 = null;
        Long lastModified = null;
        Long fileSize = null;

        // Construct and send outgoing request
        String request;
        switch (command) {
            case "DIRECTORY_CREATE":
                request = Messages.getDirectoryCreateRequest(pathName);
                send(request);
                break;
            case "DIRECTORY_DELETE":
                request = Messages.getDirectoryDeleteRequest(pathName);
                send(request);
                break;
            case "FILE_CREATE":
            case "FILE_DELETE":
            case "FILE_MODIFY":
                assert(fileDescriptor != null);
                md5 = fileDescriptor.md5;
                lastModified = fileDescriptor.lastModified;
                fileSize = fileDescriptor.fileSize;
                switch (command) {
                    case "FILE_CREATE":
                        request = Messages.getFileCreateRequest(md5, lastModified, fileSize, pathName);
                        send(request);
                        break;
                    case "FILE_DELETE":
                        request = Messages.getFileDeleteRequest(md5, lastModified, fileSize, pathName);
                        send(request);
                        break;
                    case "FILE_MODIFY":
                        request = Messages.getFileModifyRequest(md5, lastModified, fileSize, pathName);
                        send(request);
                        break;
                    default:
                        break;
                }
                break;
            default:
                log.warning("Invalid command arose from file system event");
                break;
        }
    }

    public void close() {
        this.closed = true;
    }

    public void enqueue(FileSystemEvent event) {
        log.info(event.event.name() + " added to PeerClient queue");
        this.events.add(event);
    }

    /**
     * Responsible for handling outgoing requests generated
     * by general file system events to a single connected peer,
     * until that connection is closed. Also generates
     * and sends sync events after every syncInterval period.
     */
    @Override
    public void run() {

        while (!closed) {
            try {
                // Need to sleep to ensure file system events
                // are actually processed. If we don't then
                // for some reason they aren't processed.
                Thread.sleep(250);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            // Process general file system events, relay them
            // as outgoing messages to connected peers
            FileSystemManager.FileSystemEvent event;
            try {
                if ((event = this.events.poll()) != null) {
                    log.info("PROCESSING NEW FILE SYSTEM EVENT");
                    handleOutgoingClientMessage(event);
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * Sends a request/response string to the connected peer.
     * Appends a newline char to the outgoing message.
     * @param message request or response message
     * @throws IOException
     */
    private void send(String message) throws IOException {
        out.write(message + '\n');
        out.flush();
        log.info("Sending: " + message);
    }
}